# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qZko9zcrVpAT_EdWSXGEbwcwr4Rflk9p
"""

# === app.py Code (Full Version) ===
import streamlit as st
import requests
import json
import time
import os
from moviepy.editor import VideoFileClip # For extracting audio from video
from google.colab import userdata # To access Colab Secrets
import streamlit as st

try:
    ASSEMBLYAI_API_KEY = st.secrets["assemblyai_api_key"] 
except KeyError:
    st.error("AssemblyAI API Key not found in Streamlit Secrets. Please add it to your Streamlit Cloud app settings.")
    st.stop() # Stop the app if key is missing

# AssemblyAI API Endpoints
UPLOAD_ENDPOINT = "https://api.assemblyai.com/v2/upload"
TRANSCRIPT_ENDPOINT = "https://api.assemblyai.com/v2/transcript"

headers = {
    "authorization": ASSEMBLYAI_API_KEY,
    "content-type": "application/json"
}

# --- Functions ---

def upload_file_to_assemblyai(filepath):
    """Uploads a local file to AssemblyAI for processing."""
    try:
        with open(filepath, "rb") as f:
            response = requests.post(UPLOAD_ENDPOINT, headers=headers, data=f)
        response.raise_for_status() # Raise an exception for HTTP errors
        return response.json()["upload_url"]
    except requests.exceptions.RequestException as e:
        st.error(f"Error uploading file: {e}")
        return None

def submit_for_transcription_and_translation(audio_url):
    """Submits the audio URL to AssemblyAI for transcription and English translation."""
    try:
        data = {
            "audio_url": audio_url,
            "language_detection": True, # Automatically detect source language
            "punctuate": True,
            "format_text": True,
            "translate_to": "en" # Translate to English
        }
        response = requests.post(TRANSCRIPT_ENDPOINT, headers=headers, json=data)
        response.raise_for_status()
        return response.json()["id"] # Returns the ID of the transcript job
    except requests.exceptions.RequestException as e:
        st.error(f"Error submitting transcription job: {e}")
        return None

def get_transcript_result(transcript_id):
    """Polls AssemblyAI for the transcript result."""
    polling_endpoint = f"{TRANSCRIPT_ENDPOINT}/{transcript_id}"
    while True:
        try:
            polling_response = requests.get(polling_endpoint, headers=headers)
            polling_response.raise_for_status()
            transcription_result = polling_response.json()

            if transcription_result["status"] == "completed":
                return transcription_result
            elif transcription_result["status"] == "failed":
                st.error(f"Transcription failed: {transcription_result.get('error')}")
                return None

            time.sleep(5) # Wait 5 seconds before checking again
        except requests.exceptions.RequestException as e:
            st.error(f"Error getting transcript result: {e}")
            return None

def generate_srt_from_translation(transcript_id):
    """Fetches the translated SRT content from AssemblyAI."""
    try:
        srt_endpoint = f"{TRANSCRIPT_ENDPOINT}/{transcript_id}/srt"
        srt_headers = {
            "authorization": ASSEMBLYAI_API_KEY,
            "Accept": "text/plain" # Request plain text for SRT
        }
        response = requests.get(srt_endpoint, headers=srt_headers)
        response.raise_for_status()
        return response.text
    except requests.exceptions.RequestException as e:
        st.error(f"Error fetching SRT: {e}")
        return None

def extract_audio_from_video(video_path, audio_output_path="temp_audio.mp3"):
    """Extracts audio from a video file using moviepy."""
    try:
        video = VideoFileClip(video_path)
        video.audio.write_audiofile(audio_output_path)
        return audio_output_path
    except Exception as e:
        st.error(f"Error extracting audio from video: {e}")
        return None

def process_srt_file_for_translation(srt_file_path):
    """
    Processes an SRT file by extracting text, and then attempts to translate it.
    NOTE: Direct SRT translation with timecode preservation is complex.
    This function will simply extract text and send to a generic translation service (conceptual).
    For perfect timecode preservation, extracting audio from video/audio and then using AAI's full service is recommended.
    """
    st.warning("Translating an existing SRT file while preserving perfect timecodes is complex.")
    st.warning("For best results, consider submitting the original video/audio to AssemblyAI.")

    try:
        extracted_text = ""
        with open(srt_file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                # Skip index numbers and timecodes
                if line.isdigit() or '-->' in line or not line:
                    continue
                extracted_text += line + " " # Append text with a space

        if not extracted_text.strip():
            st.error("No translatable text found in the SRT file.")
            return None

        st.info("Sending extracted text for conceptual translation (requires a separate text translation API usually).")
        st.info("As AssemblyAI excels in audio/video processing, direct SRT text translation is not its primary feature.")
        st.info("You would typically use a dedicated text translation API like Google Cloud Translation or DeepL for this.")

        # For a simplified demonstration, let's just show the extracted text.
        st.subheader("Extracted Text from SRT:")
        st.write(extracted_text)
        st.warning("To get an SRT output, AssemblyAI needs an audio source.")
        return None # Indicate that direct SRT-to-SRT translation isn't fully supported by this AAI workflow.

    except Exception as e:
        st.error(f"Error processing SRT file: {e}")
        return None

# --- Streamlit UI ---
st.set_page_config(page_title="Universal Subtitle Translator", layout="centered")

st.title("ðŸŽ¬ Universal Subtitle Translator")
st.markdown("Easily convert Video/SRT files into **English Subtitles** using AI!")

st.markdown("""
<style>
.stButton>button {
    width: 100%;
    border-radius: 0.5rem;
    padding: 0.8rem;
    font-size: 1.1rem;
    background-color: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
}
.stButton>button:hover {
    background-color: #45a049;
}
.stFileUploader>div>div {
    border-radius: 0.5rem;
    border: 2px dashed #4CAF50;
    padding: 20px;
    text-align: center;
}
</style>
""", unsafe_allow_html=True)

option = st.radio(
    "Choose input type:",
    ('Upload Video File', 'Upload SRT File (Experimental)'),
    horizontal=True
)

# Temporary directory for uploaded files
if not os.path.exists("temp"):
    os.makedirs("temp")

if option == 'Upload Video File':
    uploaded_file = st.file_uploader("Upload a video file (e.g., MP4, MOV)", type=["mp4", "mov", "avi", "mkv"])
    if uploaded_file is not None:
        file_details = {"FileName": uploaded_file.name, "FileType": uploaded_file.type, "FileSize": uploaded_file.size}
        st.write(file_details)

        temp_video_path = os.path.join("temp", uploaded_file.name)
        with open(temp_video_path, "wb") as f:
            f.write(uploaded_file.getbuffer())

        st.info(f"Processing '{uploaded_file.name}'...")
        st.spinner("Extracting audio and uploading to AssemblyAI...")

        temp_audio_path = extract_audio_from_video(temp_video_path)

        if temp_audio_path:
            audio_upload_url = upload_file_to_assemblyai(temp_audio_path)

            if audio_upload_url:
                st.success("Audio uploaded successfully to AssemblyAI!")
                st.info("Submitting for transcription and translation to English...")

                transcript_id = submit_for_transcription_and_translation(audio_upload_url)

                if transcript_id:
                    st.info(f"Transcription Job ID: {transcript_id}. This may take a few minutes...")

                    with st.spinner('Translating and generating SRT...'):
                        result = get_transcript_result(transcript_id)

                        if result and result["status"] == "completed":
                            st.success("Translation completed!")
                            srt_content = generate_srt_from_translation(transcript_id)

                            if srt_content:
                                st.subheader("Generated English SRT:")
                                st.text_area("SRT Content", srt_content, height=300)

                                st.download_button(
                                    label="Download English SRT",
                                    data=srt_content,
                                    file_name=f"{os.path.splitext(uploaded_file.name)[0]}_english.srt",
                                    mime="text/plain"
                                )
                            else:
                                st.error("Failed to generate SRT content.")
                        else:
                            st.error("Transcription or Translation process failed.")

            if os.path.exists(temp_audio_path):
                os.remove(temp_audio_path)

        if os.path.exists(temp_video_path):
            os.remove(temp_video_path)

elif option == 'Upload SRT File (Experimental)':
    uploaded_srt_file = st.file_uploader("Upload an SRT file (e.g., .srt)", type=["srt"])
    if uploaded_srt_file is not None:
        st.write({"FileName": uploaded_srt_file.name, "FileType": uploaded_srt_file.type, "FileSize": uploaded_srt_file.size})

        temp_srt_path = os.path.join("temp", uploaded_srt_file.name)
        with open(temp_srt_path, "wb") as f:
            f.write(uploaded_srt_file.getbuffer())

        st.info(f"Processing '{uploaded_srt_file.name}'...")

        process_srt_file_for_translation(temp_srt_path)

        if os.path.exists(temp_srt_path):
            os.remove(temp_srt_path)

        st.warning("Note: Direct SRT translation with perfect timecode preservation is not fully supported by this workflow's primary method (AssemblyAI). For best results, use the 'Upload Video File' option with your original video or audio.")

st.markdown("---")
st.markdown("Developed with â¤ï¸ using AssemblyAI and Streamlit.")


# Save your Streamlit app code to a file named app.py
# (The entire app.py code from step 4 is implicitly put here)
with open('app.py', 'w') as f:
    f.write("""
    # Paste your ENTIRE Streamlit app.py code here from step 4.
    # This is a placeholder for the actual code.
    # The content from step 4 should replace this multi-line string.
    # I'm not duplicating the large code block here again for brevity.
    """)
    # !!! IMPORTANT: Replace the above multi-line string with the FULL app.py code from step 4 !!!

# Run Streamlit app in the background
!streamlit run app.py &>/dev/null&
